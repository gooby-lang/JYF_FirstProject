### 1.HTTP的基本流程
    
HTTP请求/响应的基本步骤：

+ 1、浏览器进行DNS域名解析，得到对应的IP地址
+ 2、根据这个IP，找到对应的服务器建立TCP连接（三次握手）
+ 3、建立TCP连接后发起HTTP请求（一个完整的HTTP请求报文）
+ 4、服务器响应HTTP请求，浏览器得到HTML代码（服务器如何响应）
+ 5、浏览器解析HTML代码，并请求HTML代码中的资源（如js、css、图片等）
+ 6、浏览器对页面进行渲染并呈现给用户
+ 7、服务器关闭TCP连接（四次挥手）

### 2.HTTP建立连接的详细过程（三次握手）

#### 主要是TCP的三次握手，首先了解下TCP

+ TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP／IP
协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方
的序列号和确认号并交换TCP窗口大小信息。

#### 接下来是三次握手的过程

+ 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x。然后
客户端进入SYN_SEND状态，等待服务器的确认。
+ 第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgement Number为
x+1(Sequence Number+1)；同时自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将
上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
+ 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgement Number设置为y+1，向服务器发送ACK
报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

#### 为什么要三次握手

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

例如：假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了
以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此
失效的报文段后，就误认为是client再次发出的一个新连接请求，于是就向client发出确认报文段，同意建立连接。
假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。但是client事实上并没有连接的请求，
因此server就会一直等待client的数据，server的资源就浪费了很多。
如果采用“三次握手”就可以避免这种情况的发生。

（我自己的理解）：通俗点说，三次握手分别就是

1、client告诉server，我要建立连接了

2、server告诉client，好的，我可以给你建立连接

3、client告诉server，它知道server同意建立连接了

### 3.为什么说HTTP是无状态的

#### 首先需要解释什么是“无状态”

无状态是指协议对于事务处理没有记忆能力。客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，
因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态。
下一次客户端向同样的服务器发送请求的时候，由于他们之前已经遗忘了彼此，所以需要重新建立连接。

（自己的理解）：当我这次用这个浏览器发送请求给服务器的时候，服务器响应。下次用同一个浏览器再发送
同一个服务器请求的时候，服务器也响应，但是它不知道我就是刚刚那个浏览器。服务器不会记住浏览器。

#### 解答问题

+ HTTP不会为了下一次连接而维护这次连接所传输的信息，为了保证服务器内存。
+ 由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，
在设计HTTP协议的时候规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。
这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。
由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议。


### 4.HTTP都有哪几种请求方法

+ GET：请求指定的页面信息，并返回实体主体
+ POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中，
POST请求可能会导致新的资源的建立或者已有资源的修改。
+ PUT：从客户端向服务器传送的数据取代指定的文档的内容。
+ DELETE：请求服务器删除指定的页面。
+ CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
+ HEAD：类似GET请求，只不过返回的响应中没有具体的内容，用于获取报头
+ OPTIONS：允许客户端查看服务器的性能
+ TRACE：回显服务器收到的请求，主要用于测试或诊断。

最常用的两种是GET与POST

### 5.POST和GET方法有什么区别

+ GET：请求一个指定资源的表示形式，用于获取数据
+ POST：用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用

本质上都是TCP连接，但是还是有以下不同。

+ GET在浏览器回退时是无害的，而POST会再次提交请求。
+ GET产生的URL地址可以被Bookmark，而POST不可以。
+ GET请求会被浏览器主动cache，而POST不会，除非手动设置。
+ GET请求只能进行URL编码，而POST支持多种编码方式
+ GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
+ GET请求在URL中传送的参数是有长度限制的，而POST没有。
+ 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
+ GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
+ GET参数通过URL传递，POST放在Request body中。

#### 参考文献
[https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd](https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd)



### 6.什么时候用GET？什么时候用POST？

当请求无副作用时（如进行搜索），则可以使用GET方法；
当请求有副作用时（例如添加数据行），则用POST方法。

当符合以下任一情况，则用POST方法：
+ 请求的结果有持续性的副作用，例如数据库内添加新的数据行
+ 若使用GET方法，则表单上收集的数据可能让URL过长
+ 要传送的数据不是采用7位的ASCII编码

当符合以下任一情况，则用GET方法：
+ 请求是为了查找资源，HTML表单数据仅用来帮助搜索
+ 请求结果无持续性的副作用
+ 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符（URL限制）。

### 7.HTTP位于哪一层？TCP位于哪一层？

HTTP属于应用层协议

TCP属于传输层协议

### 8.HTTP的状态码有哪些？给出三个常见的状态码的含义

+ 信息响应（100-199）
+ 成功响应（200-299）
+ 重定向消息（300-399）
+ 客户端错误响应（400-499）
+ 服务端错误响应（500-599）

#### 常用状态码
+ 200 OK 请求成功，一般用于GET与POST请求
+ 304 Not Modified 未修改
+ 404 Not Found 请求的网页不存在
+ 500 Internal Server Error 服务器内部错误
+ 503 Service Unavailable 服务器暂时不可用

#### 信息响应
100 Conitnue
> 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已完成，则忽略

101 Switching Proticols
> 切换协议。服务器根据客户端的请求切换协议，只能切换到更高级的协议，例如切换到HTTP新版本协议

#### 成功响应
200 OK
> 请求成功，一般用于GET与POST请求

201 Created
> 已创建。成功请求并创建了新的资源

202 Accepted
> 已接受。已经接受请求，但未处理完成

203 Non-Authoritative Information
> 非授权信息。请求成功。但是返回的meta信息不在原始的服务器里，而是一个副本。

204 No Content
> 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档

205 Reset Content
> 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域

206 Partial Content
> 部分内容。服务器成功处理了部分GET请求

#### 重定向信息
300 Multiple Choices
> 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如浏览器）选择

301 Moved Permanently
> 永久移动。请求的资源已被永久的移动到新的URL，在响应中给出了新的URL。

302 Found
> 临时移动。与301类似，使用GET和POST请求查看。

304 Not Modified
> 未修改。因此客户端可以继续使用相同的缓存版本的响应。

305 Use Proxy
> 使用代理。所请求的资源必须通过代理访问。

306 Unused
> 已经被废弃的HTTP状态码

307 Temporary Redirect
> 临时重定向，与302类似，使用GET请求重定向

#### 客户端错误响应
400 Bad Request
> 客户端请求的语法错误，服务器无法理解

401 Unauthorized
> 请求要求用户的身份认证

402 Payment Required
> 保留，将来使用

403 Forbidden
> 服务器理解请求客户端的请求，但是拒绝执行此请求

404 Not Found
> 服务器无法根据客户端的请求找到该资源（网页）
通过此代码，网站设计人员可设置”您所请求的资源无法找到“的个性页面

405 Method Not Allowed
> 客户端请求中的方法被禁止

406 Not Acceptable
> 服务器无法根据客户端请求的内容特性完成请求

407 Proxy Authentication Required
> 请求要求代理的身份认证，与401类似，但是请求者应当使用代理进行授权

408 Request Time-out
> 服务器等待客户端发送的请求时间过长，超时

409 Conflict
> 服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发生了冲突

410 Gone
> 客户端请求的资源已经不存在，不同于404，如果资源以前有，
但是现在被删除了可使用410代码，网站设计可通过301代码
> 指定资源的新位置

411 Length Required
> 服务器无法处理客户端发送的不带Content-Length的请求信息

412 Precondition Failed
> 客户端请求信息的先决条件错误

413 Request Entity Too Large
> 由于请求的实体过大，服务器无法处理，因此拒绝请求。
为了防止客户端的连续请求，服务器可能会关闭连接。
如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。

414 Request-URI Too Large
> 请求的URI过长，服务器无法处理

415 Unsupported Media Type
> 服务器无法处理请求附带的媒体格式

416 Range Not Satisfiable
> 无法满足请求中Range标头字段指定的范围。该范围可能超出了目标URI数据的大小

417 Expectation Failed
> 服务器无法满足Expect的请求头信息

500 Internal Server Error
> 服务器内部错误，无法完成请求

501 Not Implemented
> 服务器不支持请求的功能，无法完成请求

502 Bad Gateway
> 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

503 Service Unavailable
> 由于超载或系统维护，服务器暂时的无法处理客户端的请求。
延时的长度可包含在服务器的Retry-After头信息中

504 Gateway Time-out
> 充当网关或代理的服务器未及时从远端服务器获取请求

505 HTTP Version Not Supported
> 服务器不支持请求中使用的HTTP版本。

### 9.cookie和session机制是什么？有什么区别？

HTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同意服务器再发起请求时被携带并发送到服务器上。
通常，它用于告知服务端两个请求是否来自同一浏览器。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。

Session 代表着服务器和客户端一次会话的过程。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，
存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。

它们之间的区别：
+ 作用范围不同，Cookie保存在客户端；Session保存在服务器端
+ 存取方式的不同，Cookie只能保存ASCII；Session可以存任意数据类型，一般情况下我们可以在Session中保持一些常用变量信息，比如说UserId等。
+ 有效期不同，Cookie可设置为长时间保持，比如我们经常使用的默认登录功能；Session一般失效时间较短，客户端关闭或者Session超时都会失效。
+ 隐私策略不同，Cookie存储在客户端，比较容易遭到不法获取；Session存储在服务端，安全性相对Cookie要好一些。
+ 存储大小不同，单个Cookie保存的数据不能超过4K，Session可存储数据远高于Cookie。

### 10.HTTP1.1的新特性（三个）

+ 连接可以复用，节省了多此打开TCP连接加载网页文档资源的时间。
+ 增加流水线操作，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
+ 支持响应分块。
+ 引入额外的缓存控制机制。
+ 引入内容协商机制，包括语言、编码、类型等；并允许客户端和服务器之间约定以最合适的内容进行交换。
+ HOST头，能够使不同域名配置在同一个IP地址的服务器上。